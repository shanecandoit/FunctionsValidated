
# Project Title: Schema & Process Management API

1. Goals & Scope:

- Develop a RESTful API to perform CRUD (Create, Read, Update, Delete) operations on four core resources:
    - Objects (Schemas): Definitions of data structures (attributes and types).
    - Tables (Samples): Collections of data rows conforming to a specific Object schema.
    - Functions (Processes): Definitions of operations with named input/output table schemas.
    - TestCases (Examples): Concrete examples of Function execution, linking specific input data Tables to expected output data Tables for a given Function.
- Provide automatic API documentation (Swagger UI / ReDoc).
- Implement basic server-rendered HTML views (using Jinja2 templates) to list and view details of these resources.
- Include simple HTML forms for creating/editing Objects, Functions, and TestCases (potentially simplified views for Tables due to data size).
- Ensure data validation using Pydantic schemas.
- Use a relational database (e.g., PostgreSQL or SQLite) with an ORM (e.g., SQLAlchemy or SQLModel).

2. Technology Stack:

Programming Language: Python 3.9+
Web Framework: FastAPI
Data Validation: Pydantic (comes built-in with FastAPI)
Database:
Development: SQLite (simple, file-based)
Production: PostgreSQL (robust, scalable)
ORM: SQLModel (combines Pydantic and SQLAlchemy) or SQLAlchemy directly. SQLModel is often preferred with FastAPI for seamless integration.
API Documentation: Swagger UI & ReDoc (automatically generated by FastAPI)
Templating Engine: Jinja2 (for HTML views/forms)
ASGI Server: Uvicorn
Testing: Pytest, FastAPI's TestClient
Dependency Management: pip and requirements.txt (or Poetry/PDM)

3. Project Structure:

schema-process-api/
├── app/                     # Main application source code
│   ├── __init__.py
│   ├── main.py              # FastAPI app instance, main router includes
│   ├── core/                # Core components (config, db session)
│   │   ├── __init__.py
│   │   ├── config.py        # Application settings (Pydantic BaseSettings)
│   │   └── database.py      # Database session setup, engine
│   ├── models/              # Database models (SQLModel/SQLAlchemy)
│   │   ├── __init__.py
│   │   ├── base.py          # Base model class (if needed)
│   │   ├── object_schema.py
│   │   ├── table_data.py
│   │   ├── function_def.py
│   │   └── test_case.py
│   ├── schemas/             # Pydantic schemas for API validation & serialization
│   │   ├── __init__.py
│   │   ├── object_schema.py # Schemas for request/response
│   │   ├── table_data.py
│   │   ├── function_def.py
│   │   └── test_case.py
│   ├── crud/                # CRUD database operations logic
│   │   ├── __init__.py
│   │   ├── base.py          # Base CRUD class (optional)
│   │   ├── crud_object.py
│   │   ├── crud_table.py
│   │   ├── crud_function.py
│   │   └── crud_test_case.py
│   ├── api/                 # API Routers/Endpoints
│   │   ├── __init__.py
│   │   ├── deps.py          # API Dependencies (e.g., get_db session)
│   │   └── v1/              # API Version 1
│   │       ├── __init__.py
│   │       ├── endpoints/
│   │       │   ├── __init__.py
│   │       │   ├── objects.py
│   │       │   ├── tables.py
│   │       │   ├── functions.py
│   │       │   └── test_cases.py
│   │       └── api.py       # Main router for v1, includes endpoint routers
│   ├── web/                 # Routers for HTML Views/Forms
│   │   ├── __init__.py
│   │   ├── forms.py         # (Optional) Form definitions if using WTForms-like lib
│   │   ├── routes.py        # Endpoints serving HTML
│   │   └── templates/       # Jinja2 HTML templates
│   │       ├── base.html
│   │       ├── objects/
│   │       │   ├── list.html
│   │       │   ├── detail.html
│   │       │   └── form.html
│   │       ├── tables/
│   │       │   ├── list.html
│   │       │   └── detail.html # Detail view might be complex
│   │       ├── functions/
│   │       │   ├── list.html
│   │       │   ├── detail.html
│   │       │   └── form.html
│   │       └── test_cases/
│   │           ├── list.html
│   │           ├── detail.html
│   │           └── form.html
│   └── static/              # Static files (CSS, JS) for web views
│       └── css/
│           └── style.css
├── tests/                   # Unit and integration tests
│   ├── __init__.py
│   ├── conftest.py          # Pytest fixtures
│   ├── api/                 # API endpoint tests
│   │   └── v1/
│   │       └── test_objects.py # etc.
│   └── crud/                # CRUD function tests
│       └── test_crud_object.py # etc.
├── .env                     # Environment variables (DB_URL, SECRET_KEY) - DO NOT COMMIT
├── .env.example             # Example environment file
├── .gitignore
├── requirements.txt         # Project dependencies
└── README.md                # Project documentation

4. Data Models (app/models/)

(Using SQLModel syntax as an example)

ObjectSchema:

id (PK, int)
name (str, unique)
description (str, nullable)
attributes (JSON) - Stores list like [{'name': 'col1', 'type': 'string'}, {'name': 'col2', 'type': 'integer'}]
tables (Relationship back to TableData)
function_inputs (Relationship back to FunctionInput)
function_outputs (Relationship back to FunctionOutput)
TableData:

id (PK, int)
name (str)
object_schema_id (FK to ObjectSchema.id)
object_schema (Relationship to ObjectSchema)
rows (JSON) - Stores list of dicts, e.g., [{'col1': 'a', 'col2': 1}, {'col1': 'b', 'col2': 2}]
test_case_inputs (Relationship back to TestCaseInputTable)
test_case_outputs (Relationship back to TestCaseOutputTable)
FunctionDefinition:

id (PK, int)
name (str, unique)
summary (str, nullable)
inputs (Relationship to FunctionInput)
outputs (Relationship to FunctionOutput)
test_cases (Relationship back to TestCase)
FunctionInput: (Link table for Function inputs)

id (PK, int)
function_id (FK to FunctionDefinition.id)
object_schema_id (FK to ObjectSchema.id)
input_name (str) - e.g., "primary_input", "parameters"
function (Relationship to FunctionDefinition)
object_schema (Relationship to ObjectSchema)
(Unique constraint on function_id, input_name)
FunctionOutput: (Link table for Function outputs)

id (PK, int)
function_id (FK to FunctionDefinition.id)
object_schema_id (FK to ObjectSchema.id)
output_name (str) - e.g., "results", "errors"
function (Relationship to FunctionDefinition)
object_schema (Relationship to ObjectSchema)
(Unique constraint on function_id, output_name)
TestCase:

id (PK, int)
name (str, unique)
summary (str, nullable)
function_id (FK to FunctionDefinition.id)
function (Relationship to FunctionDefinition)
input_tables (Relationship to TestCaseInputTable)
output_tables (Relationship to TestCaseOutputTable)
TestCaseInputTable: (Link table for TestCase input data)

id (PK, int)
test_case_id (FK to TestCase.id)
table_data_id (FK to TableData.id)
input_name (str) - Must match one of the input_names from the associated FunctionDefinition's FunctionInput records.
test_case (Relationship to TestCase)
table_data (Relationship to TableData)
(Constraint: The TableData's object_schema_id must match the object_schema_id of the corresponding FunctionInput for the TestCase's function_id and this input_name)
TestCaseOutputTable: (Link table for TestCase expected output data)

id (PK, int)
test_case_id (FK to TestCase.id)
table_data_id (FK to TableData.id)
output_name (str) - Must match one of the output_names from the associated FunctionDefinition's FunctionOutput records.
test_case (Relationship to TestCase)
table_data (Relationship to TableData)
(Constraint: The TableData's object_schema_id must match the object_schema_id of the corresponding FunctionOutput for the TestCase's function_id and this output_name)

5. API Schemas (app/schemas/)

Define Pydantic models for each resource (ObjectSchema, TableData, FunctionDefinition, TestCase).
Create variations for different operations:
...Base: Common attributes.
...Create: Attributes needed for creation (input).
...Update: Attributes allowed for update (input).
...InDBBase: Attributes stored in DB (including ID).
... (e.g., ObjectSchema): Attributes returned in API responses (output).
Handle nested structures appropriately (e.g., returning Function details with its inputs/outputs defined).
Use Pydantic's validation capabilities (e.g., field types, constraints).

6. CRUD Logic (app/crud/)

Implement functions for database interactions:
get(...), get_multi(...), create(...), update(...), remove(...) for each model.
These functions take Pydantic schemas as input (for create/update) and return database models.
Handle database session management (passed via dependency injection).
Implement logic for handling relationships (e.g., when creating a Function, also create its FunctionInput/FunctionOutput link records).
Implement logic for complex constraints (e.g., ensuring TestCaseInputTable data matches the Function's input schema).

7. API Endpoints (app/api/v1/endpoints/)

Create FastAPI APIRouter for each resource type (objects.py, tables.py, etc.).
Define standard RESTful endpoints:
POST /resource/: Create a new resource.
GET /resource/: List resources (with pagination, filtering).
GET /resource/{id}: Retrieve a specific resource.
PUT /resource/{id}: Update a specific resource.
DELETE /resource/{id}: Delete a specific resource.
Use dependency injection (Depends) to get DB sessions and potentially current user (if auth is added).
Call CRUD functions to interact with the database.
Use the defined Pydantic schemas for request body validation and response serialization (response_model).
Handle potential errors (e.g., HTTPException for 404 Not Found, 400 Bad Request).

8. Web Views & Forms (app/web/)

Create an APIRouter in app/web/routes.py.
Define endpoints that return HTMLResponse.
Use Jinja2Templates to render HTML files from app/web/templates/.
List Views: Fetch multiple items using CRUD functions and pass them to the template context.
Detail Views: Fetch a single item by ID and pass it to the template context.
Forms (Create/Edit):
GET request: Render the form template (potentially pre-filled for editing).
POST request:
Receive form data (request.form()).
Validate the data (manually or using a library like WTForms).
If valid, call the appropriate CRUD function to create/update the resource.
Redirect to the detail or list view.
If invalid, re-render the form with error messages.
Mount the web router in app/main.py (e.g., under a /web prefix).
Mount the StaticFiles directory in app/main.py to serve CSS/JS.

9. Core Components (app/core/)

config.py: Use Pydantic's BaseSettings to load configuration from environment variables (.env file). Include DATABASE_URL, SECRET_KEY, etc.
database.py: Set up the SQLAlchemy/SQLModel engine and session management (e.g., a get_db dependency function).

10. Testing (tests/)

Use pytest.
Create fixtures (conftest.py) for database setup/teardown, test client instance.
Unit Tests: Test CRUD functions in isolation (mocking DB if necessary).
Integration Tests: Use TestClient to make requests to the API endpoints and assert responses and database state changes. Test validation, success cases, and error cases.

11. Setup & Running:

Create requirements.txt with all dependencies (FastAPI, Uvicorn, SQLModel/SQLAlchemy, psycopg2-binary/sqlite, Jinja2, python-dotenv).
Provide clear instructions in README.md on:
Setting up the virtual environment.
Installing dependencies (pip install -r requirements.txt).
Creating and configuring the .env file.
Running database migrations (if using Alembic).
Running the development server (uvicorn app.main:app --reload).
Running tests (pytest).

12. Next Steps / Future Enhancements:

Authentication/Authorization: Implement user login and permissions (e.g., using FastAPI's OAuth2 utilities, JWT).
Database Migrations: Integrate Alembic for managing database schema changes.
Asynchronous Operations: Consider async database drivers and operations for improved performance.
Background Tasks: For potentially long-running processes (e.g., validating large tables).
Enhanced Web UI: Use a JavaScript framework (Vue, React, Svelte) for a more interactive frontend experience, communicating with the REST API.
"Run TestCase" Endpoint: Implement logic to simulate executing a function based on a TestCase definition (this could be complex depending on the nature of the "Functions").
Deployment: Containerize using Docker, set up CI/CD pipelines.
This plan provides a comprehensive structure and outlines the key steps for building the requested Python REST API with basic web views and forms using FastAPI.
